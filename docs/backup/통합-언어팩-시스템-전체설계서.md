# 🌐 통합 언어팩 시스템 전체 설계서

## 📅 작성일: 2025-09-02
## 🎯 목적: 기존 시스템을 유지하면서 완벽한 다국어 통합 시스템 구축

---

## 1. 🏗️ 시스템 아키텍처

### 1.1 핵심 원칙
- **기존 코드 최대한 활용**: UI 깨짐 방지
- **점진적 마이그레이션**: 단계별 적용
- **기본 3개 언어**: ko(한국어), en(영어), jp(일본어)
- **확장 가능 구조**: 추가 언어는 API 연동으로 유료화

### 1.2 데이터 흐름도
```
┌─────────────────────────────────────────────────────┐
│                  언어팩 중앙 관리                      │
│            /admin/language-packs                     │
└────────────┬────────────────────────────────────────┘
             │
    ┌────────┴────────┬──────────┬──────────┬──────────┐
    ▼                 ▼          ▼          ▼          ▼
┌─────────┐    ┌──────────┐ ┌────────┐ ┌────────┐ ┌────────┐
│ UI섹션  │    │ 헤더/푸터 │ │카테고리│ │  상품  │ │  기타  │
│ 관리    │    │   설정    │ │  관리  │ │  등록  │ │  페이지 │
└─────────┘    └──────────┘ └────────┘ └────────┘ └────────┘
     │              │           │          │           │
     └──────────────┴───────────┴──────────┴───────────┘
                            │
                    ┌───────▼────────┐
                    │   JSON 생성     │
                    │  & 캐시 시스템  │
                    └───────┬────────┘
                            │
                    ┌───────▼────────┐
                    │   메인페이지    │
                    │   실시간 반영   │
                    └────────────────┘
```

---

## 2. 🔄 언어팩 중앙 관리 시스템

### 2.1 기본 언어 설정 (3개)
```typescript
// lib/config/languages.ts
export const BASE_LANGUAGES = {
  ko: { code: 'ko', name: '한국어', flag: '🇰🇷', isDefault: true },
  en: { code: 'en', name: 'English', flag: '🇺🇸', isDefault: false },
  jp: { code: 'jp', name: '日本語', flag: '🇯🇵', isDefault: false }
} as const;

export const PREMIUM_LANGUAGES = {
  zh: { code: 'zh', name: '中文', flag: '🇨🇳', isPremium: true },
  es: { code: 'es', name: 'Español', flag: '🇪🇸', isPremium: true },
  fr: { code: 'fr', name: 'Français', flag: '🇫🇷', isPremium: true },
  // ... 추가 언어
};
```

### 2.2 언어팩 자동 생성 로직
```typescript
// lib/services/language-auto-generator.ts
export class LanguageAutoGenerator {
  private translationAPI: TranslationService;
  
  async generateTranslations(text: string, sourceLang: string = 'ko') {
    // 기본 3개 언어는 항상 생성
    const baseTranslations = {
      ko: sourceLang === 'ko' ? text : await this.translate(text, sourceLang, 'ko'),
      en: sourceLang === 'en' ? text : await this.translate(text, sourceLang, 'en'),
      jp: sourceLang === 'jp' ? text : await this.translate(text, sourceLang, 'jp')
    };
    
    // 프리미엄 언어는 구독 상태 확인 후 생성
    const premiumTranslations = await this.generatePremiumLanguages(text, sourceLang);
    
    return { ...baseTranslations, ...premiumTranslations };
  }
  
  // 한 언어만 수정해도 나머지 자동 생성
  async updateSingleLanguage(key: string, lang: string, value: string) {
    const existingPack = await this.getLanguagePack(key);
    
    // 수정된 언어를 기준으로 다른 언어 자동 생성
    const updatedPack = {
      ...existingPack,
      [lang]: value,
      // 다른 언어들 자동 번역
      ...(lang !== 'ko' && { ko: await this.translate(value, lang, 'ko') }),
      ...(lang !== 'en' && { en: await this.translate(value, lang, 'en') }),
      ...(lang !== 'jp' && { jp: await this.translate(value, lang, 'jp') })
    };
    
    return updatedPack;
  }
}
```

---

## 3. 📦 상품 등록 언어팩 통합

### 3.1 상품 등록 폼 (`/admin/products/create`)
```typescript
// components/admin/products/ProductCreateForm.tsx
interface ProductFormData {
  // 기본 정보
  sku: string;
  price: number;
  stock: number;
  
  // 다국어 필드
  translations: {
    ko: {
      name: string;
      description: string;
      shortDescription?: string;
      keywords?: string[];
    };
    en: {
      name: string;
      description: string;
      shortDescription?: string;
      keywords?: string[];
    };
    jp: {
      name: string;
      description: string;
      shortDescription?: string;
      keywords?: string[];
    };
  };
}

// 탭 방식 UI
<Tabs defaultValue="ko">
  <TabsList>
    <TabsTrigger value="ko">🇰🇷 한국어</TabsTrigger>
    <TabsTrigger value="en">🇺🇸 English</TabsTrigger>
    <TabsTrigger value="jp">🇯🇵 日本語</TabsTrigger>
  </TabsList>
  
  <TabsContent value="ko">
    <input name="translations.ko.name" placeholder="상품명 (한국어)" />
    <textarea name="translations.ko.description" placeholder="상품 설명 (한국어)" />
  </TabsContent>
  
  <TabsContent value="en">
    <input name="translations.en.name" placeholder="Product Name (English)" />
    <textarea name="translations.en.description" placeholder="Product Description (English)" />
  </TabsContent>
  
  <TabsContent value="jp">
    <input name="translations.jp.name" placeholder="商品名 (日本語)" />
    <textarea name="translations.jp.description" placeholder="商品説明 (日本語)" />
  </TabsContent>
</Tabs>

// 자동 번역 버튼
<Button onClick={autoTranslate}>
  한국어 기준 자동 번역 🔄
</Button>
```

### 3.2 상품 DB 스키마 수정
```sql
-- products 테이블 수정
ALTER TABLE products 
ADD COLUMN translations JSONB DEFAULT '{}';

-- 예시 데이터 구조
{
  "ko": {
    "name": "삼성 갤럭시 S24",
    "description": "최신 플래그십 스마트폰",
    "shortDescription": "5G 지원 프리미엄폰"
  },
  "en": {
    "name": "Samsung Galaxy S24",
    "description": "Latest flagship smartphone",
    "shortDescription": "5G Premium Phone"
  },
  "jp": {
    "name": "サムスンギャラクシーS24",
    "description": "最新フラッグシップスマートフォン",
    "shortDescription": "5Gプレミアムフォン"
  }
}
```

---

## 4. 🎨 UI Config와 상품 연동

### 4.1 섹션별 상품 표시 설정
```typescript
// 각 섹션이 어떤 상품을 표시할지 설정
interface SectionProductConfig {
  sectionId: string;
  sectionType: 'featured' | 'bestseller' | 'new' | 'sale' | 'category';
  productFilters: {
    category?: string;
    priceRange?: { min: number; max: number };
    tags?: string[];
    sortBy?: 'price' | 'popularity' | 'date' | 'rating';
    limit?: number;
  };
  displayLayout: 'grid' | 'list' | 'carousel' | 'table';
  translations: {
    ko: { title: string; subtitle?: string };
    en: { title: string; subtitle?: string };
    jp: { title: string; subtitle?: string };
  };
}
```

### 4.2 동적 섹션 렌더러 개선
```typescript
// components/DynamicSectionRenderer.tsx
const DynamicSectionRenderer = ({ language = 'ko' }) => {
  const [sections, setSections] = useState<UISection[]>([]);
  
  // 섹션 데이터 로드 (언어별)
  const loadSections = async () => {
    const response = await fetch(`/api/ui-sections?lang=${language}`);
    const data = await response.json();
    
    // 각 섹션별 상품 데이터도 함께 로드
    const sectionsWithProducts = await Promise.all(
      data.sections.map(async (section) => {
        if (section.type.includes('product')) {
          const products = await loadSectionProducts(section, language);
          return { ...section, products };
        }
        return section;
      })
    );
    
    setSections(sectionsWithProducts);
  };
  
  // 섹션별 상품 로드
  const loadSectionProducts = async (section: UISection, lang: string) => {
    const response = await fetch(`/api/products/section/${section.id}?lang=${lang}`);
    return response.json();
  };
  
  return (
    <div>
      {sections.map(section => (
        <SectionComponent
          key={section.id}
          section={section}
          language={language}
          products={section.products}
        />
      ))}
    </div>
  );
};
```

---

## 5. 🔧 기존 코드 수정 전략

### 5.1 단계별 마이그레이션

**Phase 1: 스키마 확장 (DB 변경 없이)**
```typescript
// 기존 테이블 유지하면서 JSONB 컬럼만 추가
ALTER TABLE ui_sections ADD COLUMN IF NOT EXISTS translations JSONB DEFAULT '{}';
ALTER TABLE products ADD COLUMN IF NOT EXISTS translations JSONB DEFAULT '{}';
ALTER TABLE categories ADD COLUMN IF NOT EXISTS translations JSONB DEFAULT '{}';
```

**Phase 2: API 래퍼 생성**
```typescript
// lib/api/translation-wrapper.ts
export class TranslationWrapper {
  // 기존 API 응답을 감싸서 번역 추가
  static async wrapResponse(data: any, lang: string) {
    // 기존 데이터 구조 유지
    const wrappedData = { ...data };
    
    // translations 필드가 있으면 해당 언어 데이터 병합
    if (data.translations && data.translations[lang]) {
      Object.assign(wrappedData, data.translations[lang]);
    }
    
    return wrappedData;
  }
}
```

**Phase 3: 컴포넌트 점진적 수정**
```typescript
// 기존 컴포넌트를 HOC로 감싸서 언어 지원 추가
export function withTranslation<P extends object>(
  Component: React.ComponentType<P>
): React.ComponentType<P & { language?: string }> {
  return (props: P & { language?: string }) => {
    const { language = 'ko' } = props;
    const translatedProps = useTranslatedProps(props, language);
    return <Component {...translatedProps} />;
  };
}
```

### 5.2 백워드 호환성 유지
```typescript
// 기존 데이터와 새 데이터 모두 지원
const getProductName = (product: Product, lang: string = 'ko') => {
  // 새로운 구조 확인
  if (product.translations && product.translations[lang]) {
    return product.translations[lang].name;
  }
  // 기존 구조 폴백
  return product.name || product.title || '';
};
```

---

## 6. 📊 JSON 캐시 전략

### 6.1 계층적 캐시 구조
```typescript
// lib/cache/multi-layer-cache.ts
export class MultiLayerCache {
  // Level 1: 메모리 캐시 (5분)
  private memoryCache = new Map();
  
  // Level 2: 파일 캐시 (1시간)
  private fileCache = {
    path: '/public/cache',
    ttl: 3600
  };
  
  // Level 3: CDN 캐시 (24시간)
  private cdnCache = {
    url: process.env.CDN_URL,
    ttl: 86400
  };
  
  async get(key: string, lang: string) {
    // 메모리 → 파일 → CDN 순서로 확인
    return this.memoryCache.get(`${key}-${lang}`) ||
           await this.fileCache.get(`${key}-${lang}`) ||
           await this.cdnCache.get(`${key}-${lang}`);
  }
  
  async invalidate(pattern: string) {
    // 모든 레벨 캐시 무효화
    this.memoryCache.clear();
    await this.fileCache.clear(pattern);
    await this.cdnCache.purge(pattern);
  }
}
```

### 6.2 실시간 캐시 갱신
```typescript
// Socket.io를 통한 실시간 캐시 무효화
io.on('translation:update', async (data) => {
  const { key, lang, value } = data;
  
  // 캐시 무효화
  await cache.invalidate(`*${key}*`);
  
  // 관련 JSON 재생성
  await generateJSON(key, lang);
  
  // 클라이언트에 알림
  io.emit('cache:invalidated', { key, lang });
});
```

---

## 7. 🚀 구현 로드맵

### Week 1: 기반 구축
- [ ] DB 스키마 확장 (translations JSONB 추가)
- [ ] 언어 자동 생성 서비스 구현
- [ ] Translation API 연동

### Week 2: 관리자 UI
- [ ] 언어팩 관리 UI 개선
- [ ] 상품 등록 다국어 탭 추가
- [ ] 카테고리 다국어 편집

### Week 3: 통합 및 연동
- [ ] UI Config와 상품 연동
- [ ] 헤더/푸터 다국어 적용
- [ ] 섹션별 상품 필터링

### Week 4: 최적화
- [ ] 캐시 시스템 구현
- [ ] 실시간 동기화
- [ ] 성능 테스트

---

## 8. 🔐 프리미엄 언어 API 연동

### 8.1 구독 모델
```typescript
interface SubscriptionPlan {
  basic: {
    languages: ['ko', 'en', 'jp'],
    price: 0
  };
  premium: {
    languages: ['ko', 'en', 'jp', 'zh', 'es', 'fr', 'de', 'ru'],
    price: 50000,
    apiCalls: 10000
  };
  enterprise: {
    languages: 'unlimited',
    price: 'custom',
    apiCalls: 'unlimited'
  };
}
```

### 8.2 외부 번역 API 연동
```typescript
// lib/services/external-translation.ts
export class ExternalTranslationService {
  private providers = {
    google: new GoogleTranslateAPI(),
    deepl: new DeepLAPI(),
    papago: new PapagoAPI()
  };
  
  async translate(text: string, from: string, to: string) {
    // 구독 확인
    const subscription = await this.checkSubscription();
    
    if (!subscription.includes(to)) {
      throw new Error(`Language ${to} requires premium subscription`);
    }
    
    // 최적 제공자 선택 (언어별)
    const provider = this.selectProvider(from, to);
    
    // 번역 실행 및 캐싱
    const result = await provider.translate(text, from, to);
    await this.cacheTranslation(text, from, to, result);
    
    return result;
  }
}
```

---

## 9. 📱 반응형 언어 전환

### 9.1 사용자 경험 최적화
```typescript
// hooks/useLanguageSwitch.ts
export function useLanguageSwitch() {
  const [language, setLanguage] = useState('ko');
  const [isTransitioning, setIsTransitioning] = useState(false);
  
  const switchLanguage = async (newLang: string) => {
    setIsTransitioning(true);
    
    // 부드러운 전환 애니메이션
    await fadeOut();
    
    // 언어 변경
    setLanguage(newLang);
    
    // 데이터 프리페치
    await prefetchLanguageData(newLang);
    
    // 페이드인
    await fadeIn();
    setIsTransitioning(false);
  };
  
  return { language, switchLanguage, isTransitioning };
}
```

### 9.2 SEO 최적화
```typescript
// app/[lang]/layout.tsx
export async function generateStaticParams() {
  return BASE_LANGUAGES.map((lang) => ({
    lang: lang.code
  }));
}

export async function generateMetadata({ params }: { params: { lang: string } }) {
  const t = await getTranslations(params.lang);
  
  return {
    title: t('site.title'),
    description: t('site.description'),
    alternates: {
      languages: {
        'ko': '/ko',
        'en': '/en',
        'ja': '/jp'
      }
    }
  };
}
```

---

## 10. ✅ 체크리스트

### 필수 구현
- [ ] 3개 기본 언어 (ko, en, jp) 완벽 지원
- [ ] 한 언어 수정 시 나머지 자동 생성
- [ ] 상품 등록 다국어 지원
- [ ] UI Config와 상품 연동
- [ ] 기존 UI 유지하면서 점진적 개선

### 선택 구현
- [ ] 프리미엄 언어 API 연동
- [ ] CDN 캐시 최적화
- [ ] A/B 테스트 지원
- [ ] 언어별 검색 최적화

---

## 💡 결론

이 설계는 기존 시스템을 최대한 유지하면서 점진적으로 완벽한 다국어 시스템을 구축하는 방안입니다.

**핵심 특징:**
1. **기존 코드 보존**: UI 깨짐 없이 안전한 마이그레이션
2. **자동화**: 한 언어만 수정해도 나머지 자동 생성
3. **확장성**: 3개 기본 언어 + 프리미엄 언어 추가 가능
4. **통합성**: 모든 관리 기능이 언어팩과 연동

단계별로 구현하면 안정적이고 부드러운 다국어 시스템을 구축할 수 있습니다.